## Script used for data pre-processing, sample integration and clustering


setwd("C:/Users/ankita.lawarde/OneDrive - Tartu Ülikool/backup/scRNA-seq/cell_ranger_count_output")
outdirP = "endo_peri_diff"
options(future.globals.maxSize = 4000 * 1024^2)

################################ for filterred data from cell ranger ###################################
### fileterd data from cell ranger was used for data preprocessing.

# Load required libraries

library(SingleCellExperiment)
library(Seurat)
library(tidyverse)
library(Matrix)
library(scales)
library(cowplot)
library(RCurl)
#install.packages("remotes")
#remotes::install_github("chris-mcginnis-ucsf/DoubletFinder")
library(DoubletFinder)

##########################################################################################################
############################# Read data  #################################################################
# Step 1: Create a vector of convenient sample names, such as “A”, “B”, and “C”:
samples = c("E_398_1", "E_002_1", "E_421_1", "E_432_1", "P_398_4", "P_002_4", "P_421_4", "P_432_5")
#samples[1]

#Step 2: Read in the feature-barcode matrices generated by the cellranger pipeline
data.10x = list(); # first declare an empty list in which to hold the feature-barcode matrices

data.10x[[1]] <- Read10X(data.dir = "E_398_1_OUTPUT/raw_feature_bc_matrix")
data.10x[[2]] <- Read10X(data.dir = "E_002_1_OUTPUT/raw_feature_bc_matrix")
data.10x[[3]] <- Read10X(data.dir = "E_421_1_OUTPUT/raw_feature_bc_matrix")
data.10x[[4]] <- Read10X(data.dir = "E_432_1_OUTPUT/raw_feature_bc_matrix")
#data.10x

data.10x[[5]] <- Read10X(data.dir = "P_398_4_OUTPUT/raw_feature_bc_matrix")
data.10x[[6]] <- Read10X(data.dir = "P_002_4_OUTPUT/raw_feature_bc_matrix")
data.10x[[7]] <- Read10X(data.dir = "P_421_4_OUTPUT/raw_feature_bc_matrix")
data.10x[[8]] <- Read10X(data.dir = "P_432_5_OUTPUT/raw_feature_bc_matrix")

data.10x


#Step 3: Convert each feature-barcode matrix to a Seurat object
scrna.list = list() # First create an empty list to hold the Seurat objects
scrna.list

for (i in 1:length(data.10x)) {
  scrna.list[[i]] = CreateSeuratObject(counts = data.10x[[i]], min.features=100, project=samples[i]);
  scrna.list[[i]][["DataSet"]] = samples[i];
}

scrna.list

#Step 4. Merge the Seurat objects into a single object
scrna <- merge(x=scrna.list[[1]], 
               y=c(scrna.list[[2]],
                   scrna.list[[3]], 
                   scrna.list[[4]],
                   scrna.list[[5]], 
                   scrna.list[[6]], 
                   scrna.list[[7]], 
                   scrna.list[[8]]), 
               add.cell.ids = c("E_398_1", "E_002_1", "E_421_1", 
                                "E_432_1", "P_398_4", "P_002_4", 
                                "P_421_4", "P_432_5"), project="ENDO")

########################################################################################################
## remove the list created above to save memory
rm(scrna.list)
########################################################################################################


#######################################################################################################
# Check that the merged object has the appropriate sample-specific prefixes
head(scrna@meta.data)
tail(scrna@meta.data)

# Explore merged metadata
#View(scrna_cellranger@meta.data)


#########################################################################################################
## Step 5:
## The number of genes per UMI for each cell is quite easy to calculate, and 
## we will log10 transform the result for better comparison between samples.
## Add number of genes per UMI for each cell to metadata

scrna$log10GenesPerUMI <- log10(scrna$nFeature_RNA) / log10(scrna$nCount_RNA)


##########################################################################################################
## Step 6:
## Compute percent mito ratio

scrna$mitoRatio <- PercentageFeatureSet(object = scrna, pattern = "^MT-")
scrna$mitoRatio <- scrna@meta.data$mitoRatio / 100

## Step 7:
## compute percent ribosomal transcript ratio

scrna$riboRatio <- PercentageFeatureSet(object = scrna, pattern = "^RP[SL][[:digit:]]")
scrna$riboRatio <- scrna@meta.data$riboRatio / 100
#scrna$riboRatio

## check the metadata
head(scrna@meta.data)


#######################################################################################################
### Create metadata dataframe #########################################################################
metadata <- scrna@meta.data
head(metadata)

#####################################################################################################
## Step 8:
## Create sample column  
metadata$sampleType <- NA
metadata$sampleType[which(str_detect(metadata$DataSet, "^E_"))] <- "Endometrium"
metadata$sampleType[which(str_detect(metadata$DataSet, "^P_"))] <- "Peritonial_lesion"

tail(metadata)
head(scrna@meta.data)

#######################################################################################################
## Step 9:
## Add metadata back to Seurat object
scrna@meta.data <- metadata
head(metadata)
head(scrna@meta.data)

#######################################################################################################
# Filter out low quality reads using selected thresholds - these will change with experiment
#######################################################################################################
## Step 10:
filtered_seurat <- subset(x = scrna, 
                          subset= (nCount_RNA >= 500) & 
                            (nFeature_RNA >= 200) & 
                            (log10GenesPerUMI > 0.80) & 
                            (mitoRatio <  0.15))



#########################################################################################################
## Step 11:
## Gene-level filtering
# Output a logical vector for every gene on whether the more than zero counts per cell
# Extract counts
counts <- GetAssayData(object = filtered_seurat, slot = "counts")
counts

# Output a logical vector for every gene on whether the more than zero counts per cell
nonzero <- counts > 0
nonzero

# Sums all TRUE values and returns TRUE if more than 3 TRUE values per gene
keep_genes <- Matrix::rowSums(nonzero) >= 3
table(keep_genes)

# Only keeping those genes expressed
filtered_counts <- counts[keep_genes, ]
head(filtered_seurat@meta.data)

# Reassign to filtered Seurat object
filtered_seurat <- CreateSeuratObject(filtered_counts, meta.data = filtered_seurat@meta.data)


# Save filtered subset to new metadata
metadata_clean <- filtered_seurat@meta.data
head(metadata_clean)

# Create .RData object to load at any time
#save(filtered_seurat, file="seurat_filtered_cellranger.RData")


####################### Check cell cycle genes #######################################################
#Step 12. Calculate a cell cycle score for each cell
cell.cycle.tirosh <- read.csv("http://genomedata.org/rnaseq-tutorial/scrna/CellCycleTiroshSymbol2ID.csv", header=TRUE); # read in the list of genes
cell.cycle.tirosh
s.genes = cell.cycle.tirosh$Gene.Symbol[which(cell.cycle.tirosh$List == "G1/S")]; # create a vector of S-phase genes
s.genes
g2m.genes = cell.cycle.tirosh$Gene.Symbol[which(cell.cycle.tirosh$List == "G2/M")]; # create a vector of G2/M-phase genes


###########################################################################################################
## Step 13:
# Split seurat object by condition to perform cell cycle scoring and SCT on all samples

split_seurat <- SplitObject(filtered_seurat, split.by = "orig.ident")

split_seurat <- split_seurat[c("E_398_1", "E_002_1", "E_421_1", "E_432_1", "P_398_4", "P_002_4", "P_421_4", "P_432_5")]

for (i in 1:length(split_seurat)) {
  split_seurat[[i]] <- NormalizeData(split_seurat[[i]], verbose = TRUE)
  split_seurat[[i]] <- CellCycleScoring(split_seurat[[i]], g2m.features = g2m.genes, s.features = s.genes)
  split_seurat[[i]] <- SCTransform(split_seurat[[i]], vars.to.regress = c("mitoRatio", "Phase"))
}

split_seurat

## save filtered and normalized data
saveRDS(split_seurat, file = "split_seurat.rds")

split_seurat <- readRDS(file = "split_seurat.rds")


#########################################################################################################
## Step 14:
## run doubletfinder
## loop through samples to find doublets
###########################################################################################################

library(parallel)

for (i in 1:length(split_seurat)) {
  # print the sample we are on
  print(paste0("Sample ",i))
  sample <- split_seurat[[i]]
  sample <- RunPCA(sample, nfeatures.print = 10)
  
  # Find significant PCs
  stdv <- sample[["pca"]]@stdev
  sum.stdv <- sum(sample[["pca"]]@stdev)
  percent.stdv <- (stdv / sum.stdv) * 100
  cumulative <- cumsum(percent.stdv)
  co1 <- which(cumulative > 90 & percent.stdv < 5)[1]
  co2 <- sort(which((percent.stdv[1:length(percent.stdv) - 1] - 
                       percent.stdv[2:length(percent.stdv)]) > 0.1), 
              decreasing = T)[1] + 1
  min.pc <- min(co1, co2)
  min.pc
  
  # finish pre-processing
  sample <- RunUMAP(sample, dims = 1:min.pc)
  sample <- FindNeighbors(object = sample, dims = 1:min.pc)              
  sample <- FindClusters(object = sample, resolution = 0.1)
  
  # pK identification (no ground-truth)
  sweep.list <- paramSweep_v3(sample, PCs = 1:min.pc, sct = TRUE)
  sweep.stats <- summarizeSweep(sweep.list)
  bcmvn <- find.pK(sweep.stats)
  
  # Optimal pK is the max of the bomodality coefficent (BCmvn) distribution
  bcmvn.max <- bcmvn[which.max(bcmvn$BCmetric),]
  optimal.pk <- bcmvn.max$pK
  optimal.pk <- as.numeric(levels(optimal.pk))[optimal.pk]
  
  ## Homotypic doublet proportion estimate
  annotations <- sample@meta.data$seurat_clusters
  homotypic.prop <- modelHomotypic(annotations) 
  nExp.poi <- round(optimal.pk * nrow(sample@meta.data)) ## Assuming 1.6% doublet formation rate - tailor for your dataset
  nExp.poi.adj <- round(nExp.poi * (1 - homotypic.prop))
  
  # run DoubletFinder
  sample <- doubletFinder_v3(seu = sample,
                             PCs = 1:min.pc, 
                             pK = optimal.pk,
                             nExp = nExp.poi.adj, sct = TRUE)
  
  metadata <- sample@meta.data
  dim(metadata)
  colnames(metadata)[length(colnames(metadata))] <- "doublet_finder"
  sample@meta.data <- metadata 
  
  # subset and save
  singlets <- subset(sample, doublet_finder == "Singlet")
  split_seurat[[i]] <- singlets
  remove(singlets)
}


## check the metadata after doubletFinder
split_seurat[[1]]@meta.data
dim(split_seurat[[1]]@meta.data)
split_seurat[[1]]@meta.data
split_seurat[[1]]@assays
length(colnames(split_seurat[[1]]@meta.data))
colnames(split_seurat[[1]]@meta.data)
head(split_seurat[[1]]@meta.data[length(colnames(split_seurat[[1]]@meta.data))])

############################################################################################
#remove all predicted doublets from our data.
for (i in 1:length(split_seurat)) {
  split_seurat[[i]] = split_seurat[[i]][,split_seurat[[i]]@meta.data[,15] == "Singlet"]
}
split_seurat

## save data after doubletfinder
saveRDS(split_seurat, file = "spli_seurat_SCT_afterdoubletFinder.rds")

#######################################################################################################

### load the doubelt removed data
split_seurat <- readRDS(file = "spli_seurat_SCT_afterdoubletFinder.rds")

split_seurat
table(split_seurat$E_398_1@meta.data$DataSet)
table(split_seurat$E_002_1@meta.data$DataSet)
table(split_seurat$E_421_1@meta.data$DataSet)
table(split_seurat$E_432_1@meta.data$DataSet)
table(split_seurat$P_398_4@meta.data$DataSet)
table(split_seurat$P_002_4@meta.data$DataSet)
table(split_seurat$P_421_4@meta.data$DataSet)
table(split_seurat$P_432_5@meta.data$DataSet)

# Check which assays are stored in objects, select anyone sample
split_seurat$P_398_4@reductions


### Intgarte 8 samples ##################################################################
## Step 15:
# Select the most variable features to use for integration
integ_features <- SelectIntegrationFeatures(object.list = split_seurat, 
                                            nfeatures = 5000) 


## Step 16:
# Prepare the SCT list object for integration
split_seurat <- PrepSCTIntegration(object.list = split_seurat, 
                                   anchor.features = integ_features)

## Step 17:
# Find best buddies - can take a while to run
integ_anchors <- FindIntegrationAnchors(object.list = split_seurat, 
                                        normalization.method = "SCT", 
                                        anchor.features = integ_features)


## Step 18:
## Integrate across conditions
seurat_integrated <- IntegrateData(anchorset = integ_anchors, 
                                   normalization.method = "SCT")


# Save integrated seurat object
saveRDS(seurat_integrated, file = "seurat_integrated_endo_peri.rds")

seurat_integrated <- readRDS(file = "seurat_integrated_endo_peri.rds")
seurat_integrated


###############################################################################################
############# cell clustering #################################################################

# Select the RNA counts slot to be the default assay
DefaultAssay(seurat_integrated) <- "RNA"

# Normalize RNA data for visualization purposes
seurat_integrated <- NormalizeData(seurat_integrated, verbose = FALSE)

seurat_integrated@assays

seurat_counts <- GetAssayData(object = seurat_integrated, slot = "counts")
seurat_counts
dim(seurat_counts)

write.table(seurat_counts, file = "endo_peri_8_samples_count_matrix.txt")


# Run PCA
seurat_integrated <- RunPCA(object = seurat_integrated)

# Plot PCA
PCAPlot(seurat_integrated,
        split.by = "orig.ident")  


# Run UMAP
seurat_integrated <- RunUMAP(seurat_integrated, 
                             dims = 1:40,
                             reduction = "pca")

# Plot UMAP                             
DimPlot(seurat_integrated, group.by = "DataSet", split.by = "sampleType")


# Explore heatmap of PCs
DimHeatmap(seurat_integrated, 
           dims = 1:10, 
           cells = 500, 
           balanced = TRUE)

# Printing out the most variable genes driving PCs
print(x = seurat_integrated[["pca"]], 
      dims = 1:10, 
      nfeatures = 5)


# Plot the elbow plot
ElbowPlot(object = seurat_integrated, 
          ndims = 40)


# Determine percent of variation associated with each PC
pct <- seurat_integrated[["pca"]]@stdev / sum(seurat_integrated[["pca"]]@stdev) * 100
pct

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)
cumu

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]

co1


# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
co2

# Minimum of the two calculation
pcs <- min(co1, co2)

pcs

# Create a dataframe with values
plot_df <- data.frame(pct = pct, 
                      cumu = cumu, 
                      rank = 1:length(pct))

# Elbow plot to visualize 
ggplot(plot_df, aes(cumu, pct, label = rank, color = rank > pcs)) + 
  geom_text() + 
  geom_vline(xintercept = 90, color = "grey") + 
  geom_hline(yintercept = min(pct[pct > 5]), color = "grey") +
  theme_bw()


# Determine the K-nearest neighbor graph
seurat_integrated <- FindNeighbors(object = seurat_integrated, 
                                   dims = 1:40)

seurat_integrated
seq(0.2,1.4,by = 0.1)

# Determine the clusters for various resolutions                                
seurat_integrated <- FindClusters(object = seurat_integrated,
                                  resolution = seq(0.2,1.4,by = 0.1),random.seed = 11)

suppressMessages(require(clustree))
clustree(seurat_integrated)

# Explore resolutions
seurat_integrated@meta.data %>% 
  View()

############## save the data after findcluster. ############################################################
## This is the final pre-processed, integrated and clustered data

saveRDS(seurat_integrated, file = "clusters_seurat_integrated.rds")

###########################################################################################################


### Visualizations ##########################################################################################
## load the pre-processed , integrated and clusters identified saved data 

seurat_integrated <- readRDS(file = "clusters_seurat_integrated.rds")
seurat_integrated

# Assign identity of clusters : 
Idents(object = seurat_integrated) <- "integrated_snn_res.0.6"


# Plot the UMAP
DimPlot(seurat_integrated,
        reduction = "umap",
        label = TRUE,
        label.size = 6, split.by = "sampleType")


# Extract identity and sample information from seurat object to determine the number of cells per cluster per sample
n_cells <- FetchData(seurat_integrated, 
                     vars = c("ident", "orig.ident")) %>%
  dplyr::count(ident, orig.ident) %>%
  tidyr::spread(ident, n)

# View table
View(n_cells)


write.csv(n_cells, file = paste0(outdirP, "/n_cell_in_clusters.csv"))


# UMAP of cells in each cluster by sample
DimPlot(seurat_integrated, 
        label = TRUE, 
        split.by = "sampleType")  + NoLegend()

DimPlot(seurat_integrated, 
        label = TRUE, 
        split.by = "DataSet")  + NoLegend()


# Explore whether clusters segregate by cell cycle phase
DimPlot(seurat_integrated,
        label = TRUE, 
        split.by = "Phase")  + NoLegend()

# Determine metrics to plot present in seurat_integrated@meta.data
metrics <-  c("nCount_RNA", "nFeature_RNA", "S.Score", "G2M.Score", "mitoRatio")

FeaturePlot(seurat_integrated, 
            reduction = "umap", 
            features = metrics,
            pt.size = 0.4, 
            order = TRUE,
            min.cutoff = 'q10',
            label = TRUE)


seurat_integrated


#############################################################################
#Identification of all markers for each cluster
# find markers from clusters by wilcox test analysis
markerswilcox <- FindAllMarkers(object = seurat_integrated, 
                                only.pos = FALSE,
                                logfc.threshold = 0.25)


outdirP
save(markerswilcox, file = paste0(outdirP, "/markerswilcoxtest.RData"))

################################################ 
## subste the DEGs from the wilcox method

load(file = paste0(outdirP, "/markerswilcoxtest.RData"))

dim(markerswilcox)

head(markerswilcox)

markerswilcox <- markerswilcox[abs(markerswilcox$avg_log2FC) > 0.5 & markerswilcox$p_val_adj < 0.05,]
dim(markerswilcox)
min(markerswilcox$avg_log2FC)

## add all marker genes to the marker file
paper_marker <- readxl::read_excel(path = "cell_marker_frommapping_paper.xlsx", sheet = "epithelial_subpopulation")
dim(paper_marker)
head(paper_marker)

one_list <- paper_marker[,c(5,6)]
head(one_list)

markerstype <- markerswilcox %>%
  left_join(y = unique(one_list),
            by = c("gene" = "gene3"))


head(markerstype)


## concatenate back all cell type into a single entry seprated by comma
library(plyr)
concat_df <- ddply(markerstype, .(p_val, avg_log2FC, pct.1, pct.2, p_val_adj, cluster.x, gene), summarise, cluster.y = list(cluster.y)) 

head(concat_df)
dim(concat_df)

dim(concat_df[concat_df$cluster.x == 0,])
concat_df <- data.frame(concat_df)
head(concat_df)


head(concat_df$cluster.y)
length(concat_df$cluster.y)
matrix(unlist(concat_df$cluster.y))
names(concat_df$cluster.y)

cluster.y <- plyr::ldply(concat_df$cluster.y, rbind)
head(cluster.y)
cluster.y <- cluster.y %>%
  tidyr::unite(col = "unitedcol", 1:13, sep = ",")

cluster.y$unitedcol

concat_df$cluster.y <- cluster.y$unitedcol

writexl::write_xlsx(concat_df, path = "adj_pval_lfc_maerkertype.xlsx")
writexl::write_xlsx(cluster.y, path = "clustercell_type.xlsx")

## top20 DEGS from clusters
top20_wilcox <- concat_df %>%
  group_by(cluster.x) %>% 
  top_n(n = 20, 
        wt = avg_log2FC)


writexl::write_xlsx(top20_wilcox, path = paste0(outdirP, "/top20_DEGS_by_clusters.xlsx"))


#################################################
## Find markers by roc method
markerswilcox <- FindAllMarkers(object = seurat_integrated, 
                                test.use = "roc",
                                only.pos = FALSE,
                                logfc.threshold = 0.25)


markerswilcox
markerroc <- markerswilcox

save(markerroc, file = paste0(outdirP, "/markerroc.RData"))

#################################################################################################################################################
